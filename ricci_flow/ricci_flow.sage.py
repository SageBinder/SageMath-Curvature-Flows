

# This file was *autogenerated* from the file ricci_flow.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_0p1 = RealNumber('0.1'); _sage_const_0p01 = RealNumber('0.01'); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_0p766 = RealNumber('0.766'); _sage_const_0p091 = RealNumber('0.091'); _sage_const_0p0001 = RealNumber('0.0001'); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_0p05 = RealNumber('0.05'); _sage_const_0p00001 = RealNumber('0.00001'); _sage_const_10001 = Integer(10001); _sage_const_100 = Integer(100)
import numpy as np
import os

pi = RR.pi()

plot_initial_rev_curve = True
plot_initial_m = False
plot_initial_h = False
plot_initial_K = False
plot_initial_ricci = False

folder_name = "./curve3"
print(f"Using folder: {folder_name}")
if not os.path.exists(folder_name):
    print("Folder did not exist. Creating...")
    os.mkdir(folder_name)

def path(name):
    return os.path.join(folder_name, name)


def revolve(x, y):
    # x/y are reversed to rotate around z axis
    return (lambda u, v: y(v)*cos(u), lambda u, v: y(v)*sin(u), lambda u, v: x(v))


def xy_splines_from_hm(h, m, srange=(_sage_const_0 , pi), step_size=_sage_const_0p1 , eps=_sage_const_0p01 ):
    def y(rho):
        if m(rho) < _sage_const_0 :
            print(f"negative: {rho}, {m(rho)}")
        return sqrt(m(rho))
    
    rho_space = np.linspace(srange[_sage_const_0 ], srange[_sage_const_1 ], round((srange[_sage_const_1 ] - srange[_sage_const_0 ]) / step_size))
    y_spline = spline([(rho, y(rho)) for rho in rho_space])
    
    def x(rho):
        # TODO: Don't re-integrate every time. This is O(n^2)
        return numerical_integral(lambda s: sqrt(h(s) - (y_spline.derivative(s))**_sage_const_2 ), eps, rho)[_sage_const_0 ]
    
    x_spline = spline([(rho, x(rho)) for rho in rho_space])
    
    return x_spline, y_spline


def to_spline(f, srange=(_sage_const_0 , pi), step_size=_sage_const_0p01 ):
    return spline([(s, f(s)) for s in np.linspace(srange[_sage_const_0 ], srange[_sage_const_1 ], round((srange[_sage_const_1 ] - srange[_sage_const_0 ]) / step_size))])


def hm_to_ricci_tensor(h, m, return_K=False):
    sqrt_m = spline([(rho, sqrt(m_rho_)) for rho, m_rho_ in m])
    
    def K(rho):
        return -sqrt_m.derivative(rho, order=_sage_const_2 ) / sqrt_m(rho)

    def R(rho):
        R11 = K(rho) + ((m.derivative(rho) * h.derivative(rho)) / (_sage_const_4  * m(rho) * h(rho)))
        R22 = (R11 / h(rho)) * m(rho)
        return matrix([[R11, _sage_const_0 ], [_sage_const_0 , R22]])

    return R if not return_K else (R, K)



c3 = _sage_const_0p766 
c5 = -_sage_const_0p091 
__tmp__=var("rho"); h = symbolic_expression(_sage_const_1 ).function(rho)
__tmp__=var("rho"); m = symbolic_expression(_sage_const_0p0001  + ((sin(rho) + c3*sin(_sage_const_3 *rho) + c5*sin(_sage_const_5 *rho))/(_sage_const_1  + _sage_const_3 *c3 + _sage_const_5 *c5))**_sage_const_2 ).function(rho)

eps = _sage_const_0p05 
srange=(eps, pi-eps)
h = to_spline(h, srange)
m = to_spline(m, srange)
x, y = xy_splines_from_hm(h, m, srange, eps=eps)

R, K = hm_to_ricci_tensor(h, m, return_K=True)
if plot_initial_rev_curve:
    xy_plot = parametric_plot((x, y), (x.list()[_sage_const_0 ][_sage_const_0 ], x.list()[-_sage_const_1 ][_sage_const_0 ]))
    xy_plot.save(path("initial_curve_of_revolution.png"))
if plot_initial_m:
    plot(lambda z: sqrt(m(z)), srange, title="sqrt(m)").save(path("initial_sqrt_m.gif"))
if plot_initial_h:
    plot(h, srange, title="h").save(path("initial_h.gif"))
if plot_initial_K:
    plot(K, srange, marker=",", linestyle="", title="K").save(path("initial_K.gif"))
if plot_initial_ricci:
    def R11(rho): return R(rho)[_sage_const_0 ][_sage_const_0 ]
    def R22(rho): return R(rho)[_sage_const_1 ][_sage_const_1 ]
    plot(R11, srange).save(path("initial_R11.gif"), title="R11")
    plot(R22, srange).save(path("initial_R22.gif"), title="R22")


# Ricci flow
dt = _sage_const_0p00001 
N = _sage_const_10001 
plot_gap = _sage_const_100 
space, dt = np.linspace(_sage_const_0 , dt*(N-_sage_const_1 ), N, retstep=True)

print("Running ricci flow...")
print(f"c3 = {c3}")
print(f"c5 = {c5}")
print(f"dt = {dt}")
print(f"N = {N}")
print(f"plot_gap = {plot_gap}")

plots = []
revolved_plots = []
for i in range(N):
    R = hm_to_ricci_tensor(h, m)
    def R11(rho): return R(rho)[_sage_const_0 ][_sage_const_0 ]
    def R22(rho): return R(rho)[_sage_const_1 ][_sage_const_1 ]
    print(f"Iteration {i}/{N-_sage_const_1 }, t = {dt*i}")
    
    h = spline([(rho, h_rho_ - _sage_const_2 *R11(rho)*dt) for rho, h_rho_ in h.list()])
    m = spline([(rho, m_rho_ - _sage_const_2 *R22(rho)*dt) for rho, m_rho_ in m.list()])
    x, y = xy_splines_from_hm(h, m, srange, eps=eps)
    
    if i % plot_gap == _sage_const_0 :
        plots.append(parametric_plot((x, y), (eps, pi-eps)))
        revolved_plots.append(parametric_plot3d(revolve(x, y), (_sage_const_0 , _sage_const_2 *pi), srange))

print("Animating...")
a_curve = animate(plots)
a_surf = animate(revolved_plots)

print("Saving...")
a_curve.save(path("curve_flow.gif"), show_path=True)
a_surf.save(path("surf_flow.html"), online=True, show_path=True)

